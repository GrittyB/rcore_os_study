# 所有权
## 变量绑定背后的数据交互
总的来说
- 对于基本类型（存储在栈上）的赋值操作，Rust 会自动拷贝;
- 对于复杂类型（存储在堆上）的赋值操作，则需要通过转移所有权、拷贝和克隆等操作来实现。

Copy特征
如果一个类型拥有 Copy 特征，一个旧的变量在被**赋值**给其他变量后**仍然可用**。
	任何基本类型的组合可以 Copy，不需要分配内存或某种形式资源的类型也可以 Copy。
一些Copy的类型
-   所有整数类型，比如 `u32`
-   布尔类型，`bool`，它的值是 `true` 和 `false`
-   所有浮点数类型，比如 `f64`
-   字符类型，`char`
-   元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是
-   不可变引用 `&T` ，例如[转移所有权](https://course.rs/basic/ownership/ownership.html#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83)中的最后一个例子，**但是注意: 可变引用 `&mut T` 是不可以 Copy的**



### String类型两种拷贝方式比较 
对于字符串类型 String，它是一种复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存。
因此，在对 String 进行赋值操作时
1. 如果是拷贝所有数据（深拷贝），那么无论是 String 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响。
2. 而对于只拷贝 String 本身，拷贝的速度会非常快，但会带来新的问题，因为一个值只允许有一个所有者，而现在这个值（堆上的真实字符串数据）有了两个所有者，这就会导致内存安全性 BUG 之一的二次释放（double free）错误。

为了解决这个问题，Rust 采用了所有权转移的方式，即在将 String 的所有权从一个变量转移给另一个变量时，源变量会被自动标记为无效。
这样，当源变量和目标变量都离开作用域时，只有目标变量会释放内存，而源变量不会释放任何东西，从而避免了内存安全性问题。

除了所有权转移外，还可以通过克隆方法来实现数据的深拷贝，即完整复制数据并分配新的内存。
克隆方法在初始化程序时或执行次数较少的代码中可以使用，但对于执行较为频繁的热点路径代码，使用克隆方法会极大地降低程序性能，需要小心使用。


# 引用与借用
## 基本使用
```rust
let x = 5;
let y = &x; //借用x,即获取x的引用
assert_eq!(5, *y); // 使用*解引用, 5 == *y
```

不可变引用
```rust
fn main() {
    let s = String::from("hello");

    change(&s); // 传入引用
}

fn change(some_string: &String) { // 定义为引用参数
    some_string.push_str(", world");
}
```

可变引用
```rust
fn main() {
    let mut s = String::from("hello"); // 可变参数

    change(&mut s); // 引用的可变参数
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```